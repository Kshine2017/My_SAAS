#include "rtc.h"
#include "time.h"

/* 秒中断标志，进入秒中断时置1，当时间被刷新之后清0 */
__IO uint32_t TimeDisplay = 0;
__IO uint32_t Sec_Store_flag = 0;
volatile create_flag  create_file_flag = {0};  		//打开文件标志
volatile t_run_struct_data run_time_data = {GetTempet_RunTime,ADXL345_RunTime,GetLight_RunTime,GetVoice_RunTime,POWER_CHECK_RunTime}; 	//

/*星期，生肖用文字ASCII码*/
uint8_t const *WEEK_STR[] = {"日", "一", "二", "三", "四", "五", "六"};

/*时间结构体*/
volatile struct rtc_time systmtime;
volatile struct rtc_time BeformSystmtime; //当前系统前一天的时间
volatile struct rtc_time AfterSystmtime; //当前系统后一天的时间

//设置北京时间
static void Time_set_beijingTime(uint32_t TimeVar,volatile struct rtc_time *tm);


/**********       将hour/min/sec转换成sec          *********/
unsigned int hour_sec(volatile struct rtc_time *time)
{
    return time->tm_sec + time->tm_min*60 + time->tm_hour*60*60;
}


/**延迟函数*/
void delayms(uint16_t count)
{
    u16 i = 0,j = 0;
    for( i = count ; count > 0; count --) {
        for(j = 1000; j> 0; j--) {}
    }
}


/*
 * 函数名：NVIC_Configuration
 * 描述  ：配置RTC秒中断的主中断优先级为1，次优先级为0
 * 输入  ：无
 * 输出  ：无
 * 调用  ：外部调用
 */
void RTC_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* Configure one bit for preemption priority */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

    /* Enable the RTC Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

/*
 * 函数名：RTC_Configuration
 * 描述  ：配置RTC
 * 输入  ：无
 * 输出  ：无
 * 调用  ：外部调用
 */
void RTC_Configuration(void)
{

    /* Enable PWR and BKP clocks */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);

    /* Allow access to BKP Domain */
    PWR_BackupAccessCmd(ENABLE);

    /* Reset Backup Domain */
    BKP_DeInit();

    /* Enable LSE */
    RCC_LSEConfig(RCC_LSE_ON);

    /* Wait till LSE is ready */
    while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
    {}

    /* Select LSE as RTC Clock Source */
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);

    /* Enable RTC Clock */
    RCC_RTCCLKCmd(ENABLE);

    /* Wait for RTC registers synchronization
     * 因为RTC时钟是低速的，内环时钟是高速的，所以要同步
     */
    RTC_WaitForSynchro();

    /* Wait until last write operation on RTC registers has finished */
    RTC_WaitForLastTask();

    /* Enable the RTC Second */
    RTC_ITConfig(RTC_IT_SEC, ENABLE);

    /* Wait until last write operation on RTC registers has finished */
    RTC_WaitForLastTask();

    /* Set RTC prescaler: set RTC period to 1sec */
    RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) = 1HZ */

    /* Wait until last write operation on RTC registers has finished */
    RTC_WaitForLastTask();

}

/*
 * 函数名：RTC_CheckAndConfig
 * 描述  ：检查并配置RTC
 * 输入  ：用于读取RTC时间的结构体指针
 * 输出  ：无
 * 调用  ：外部调用
 */
void RTC_CheckAndConfig(volatile struct rtc_time *tm)
{
    /*在启动时检查备份寄存器BKP_DR1，如果内容不是0xA5A5,
    则需重新配置时间并询问用户调整时间*/
    if (BKP_ReadBackupRegister(BKP_DR1) != 0xB5B5)
    {
        printf("\r\n\r\n RTC not yet configured....");

        /* RTC Configuration */
        RTC_Configuration();

        printf("\r\n\r\n RTC configured....");

        /* Adjust time by users typed on the hyperterminal */
        Time_Adjust(tm);

        BKP_WriteBackupRegister(BKP_DR1, 0xB5B5);

        Time_set_beijingTime(RTC_GetCounter(),&systmtime); //当前系统时间
        printf("当前时间 = %d:%d:%d:%d:%d:%d\r\n",systmtime.tm_year,systmtime.tm_mon,systmtime.tm_mday,systmtime.tm_hour,systmtime.tm_min,systmtime.tm_sec);
        Time_set_beijingTime(RTC_GetCounter()-86400,&BeformSystmtime);//当前系统前一天的数据。
        printf("前天当前时间 = %d:%d:%d:%d:%d:%d\r\n",BeformSystmtime.tm_year,BeformSystmtime.tm_mon,BeformSystmtime.tm_mday,BeformSystmtime.tm_hour,BeformSystmtime.tm_min,BeformSystmtime.tm_sec);
        Time_set_beijingTime(RTC_GetCounter()+86400,&AfterSystmtime);//当前系统前一天的数据。
        printf("后天当前时间 = %d:%d:%d:%d:%d:%d\r\n",AfterSystmtime.tm_year,AfterSystmtime.tm_mon,AfterSystmtime.tm_mday,AfterSystmtime.tm_hour,AfterSystmtime.tm_min,AfterSystmtime.tm_sec);

        printf("设置当前的时间戳 = %d\r\n",mktimev(&systmtime));
    }
    else
    {
        /*启动无需设置新时钟*/
        /*检查是否掉电重启*/
        if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
        {
            printf("\r\n\r\n Power On Reset occurred....");
        }
        /*检查是否Reset复位*/
        else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
        {
            printf("\r\n\r\n External Reset occurred....");
        }

        printf("\r\n No need to configure RTC....");

        /*等待寄存器同步*/
        RTC_WaitForSynchro();

        /*允许RTC秒中断*/
        RTC_ITConfig(RTC_IT_SEC, ENABLE);

        /*等待上次RTC寄存器写操作完成*/
        RTC_WaitForLastTask();
    }
    /*定义了时钟输出宏，则配置校正时钟输出到PC13*/
#ifdef RTCClockOutput_Enable
    /* Enable PWR and BKP clocks */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);

    /* Allow access to BKP Domain */
    PWR_BackupAccessCmd(ENABLE);

    /* Disable the Tamper Pin */
    BKP_TamperPinCmd(DISABLE); /* To output RTCCLK/64 on Tamper pin, the tamper
	                                 functionality must be disabled */

    /* Enable RTC Clock Output on Tamper Pin */
    BKP_RTCOutputConfig(BKP_RTCOutputSource_CalibClock);
#endif

    /* Clear reset flags */
    RCC_ClearFlag();

    Time_set_beijingTime(RTC_GetCounter(),&systmtime); //当前系统时间
    printf("当前时间 = %d:%d:%d:%d:%d:%d\r\n",systmtime.tm_year,systmtime.tm_mon,systmtime.tm_mday,systmtime.tm_hour,systmtime.tm_min,systmtime.tm_sec);
    Time_set_beijingTime(RTC_GetCounter()-86400,&BeformSystmtime);//当前系统前一天的数据。
    printf("前天当前时间 = %d:%d:%d:%d:%d:%d\r\n",BeformSystmtime.tm_year,BeformSystmtime.tm_mon,BeformSystmtime.tm_mday,BeformSystmtime.tm_hour,BeformSystmtime.tm_min,BeformSystmtime.tm_sec);
    Time_set_beijingTime(RTC_GetCounter()+86400,&AfterSystmtime);//当前系统前一天的数据。
    printf("后天当前时间 = %d:%d:%d:%d:%d:%d\r\n",AfterSystmtime.tm_year,AfterSystmtime.tm_mon,AfterSystmtime.tm_mday,AfterSystmtime.tm_hour,AfterSystmtime.tm_min,AfterSystmtime.tm_sec);

}


/*****
* 函数名  : USART_Scanf
* 描述    : 从微机超级终端获取数字值(把ASCII码转换为数字)
			本函数专用于RTC获取时间，若进行其它输入应用，要修改一下
* 输入    : - value 用户在超级终端中输入的数值
* 输出    : 输入字符的ASCII码对应的数值
* 调用    ：内部调用
***/

static uint8_t USART_Scanf(uint32_t value)
{
    uint32_t index = 0;
    uint32_t tmp[2] = {0, 0};

    while (index < 2)
    {
        /* Loop until RXNE = 1 */
        while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
        {
        }

        tmp[index++] = (USART_ReceiveData(USART1));
        if ((tmp[index - 1] < 0x30) || (tmp[index - 1] > 0x39))   /*数字0到9的ASCII码为0x30至0x39*/
        {
            printf("\n\rPlease enter valid number between 0 and %d -->:  ",value);
            index--;
        }
    }

    /* 计算输入字符的ASCII码转换为数字*/
    index = (tmp[1] - 0x30) + ((tmp[0] - 0x30) * 10);

    /* Checks */
    if (index > value)
    {
        printf("\n\rPlease enter valid number between 0 and %d", value);
        return 0xFF;
    }
    return index;
}




static u8 USART_Scanf_alltimedata(u8* tmp)
{
    u8 index = 0;
    //

    while (index < 14)//2018 0508 121212
    {
        /* Loop until RXNE = 1 */
        while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
        {

        }
        tmp[index++] = (USART_ReceiveData(USART1));
        if ((tmp[index - 1] >= 0x30) && (tmp[index - 1] <= 0x39))   /*数字0到9的ASCII码为0x30至0x39*/
        {
            //是数字
        }
        else if(tmp[index - 1]==0) //结束标志
        {
            return index;
        }
        else
        {
            //放弃该位字符
            index--;
        }
    }

    return index;
}

/*
 * 函数名：Time_Regulate
 * 描述  ：返回用户在超级终端中输入的时间值，并将值储存在
 *         RTC 计数寄存器中。
 * 输入  ：用于读取RTC时间的结构体指针
 * 输出  ：用户在超级终端中输入的时间值，单位为 s
 * 调用  ：内部调用
 */
void Time_Regulate(volatile struct rtc_time *tm)
{
    u32 Tmp_YY = 0xFF, Tmp_MM = 0xFF, Tmp_DD = 0xFF, Tmp_HH = 0xFF, Tmp_MI = 0xFF, Tmp_SS = 0xFF;

    printf("\r\n=========================Time Settings==================");

    printf("\r\n  请输入年份(Please Set Years):  20");

    while (Tmp_YY == 0xFF)
    {
        Tmp_YY = USART_Scanf(99);
    }

    printf("\n\r  年份被设置为:  20%0.2d\n\r", Tmp_YY);

    tm->tm_year = Tmp_YY+2000;

    Tmp_MM = 0xFF;

    printf("\r\n  请输入月份(Please Set Months):  ");

    while (Tmp_MM == 0xFF)
    {
        Tmp_MM = USART_Scanf(12);
    }

    printf("\n\r  月份被设置为:  %d\n\r", Tmp_MM);

    tm->tm_mon= Tmp_MM;

    Tmp_DD = 0xFF;

    printf("\r\n  请输入日期(Please Set Dates):  ");

    while (Tmp_DD == 0xFF)
    {
        Tmp_DD = USART_Scanf(31);
    }

    printf("\n\r  日期被设置为:  %d\n\r", Tmp_DD);

    tm->tm_mday= Tmp_DD;

    Tmp_HH  = 0xFF;

    printf("\r\n  请输入时钟(Please Set Hours):  ");

    while (Tmp_HH == 0xFF)
    {
        Tmp_HH = USART_Scanf(23);
    }

    printf("\n\r  时钟被设置为:  %d\n\r", Tmp_HH );

    tm->tm_hour= Tmp_HH;

    Tmp_MI = 0xFF;

    printf("\r\n  请输入分钟(Please Set Minutes):  ");

    while (Tmp_MI == 0xFF)
    {
        Tmp_MI = USART_Scanf(59);
    }

    printf("\n\r  分钟被设置为:  %d\n\r", Tmp_MI);

    tm->tm_min= Tmp_MI;

    Tmp_SS = 0xFF;

    printf("\r\n  请输入秒钟(Please Set Seconds):  ");

    while (Tmp_SS == 0xFF)
    {
        Tmp_SS = USART_Scanf(59);
    }

    printf("\n\r  秒钟被设置为:  %d\n\r", Tmp_SS);

    tm->tm_sec= Tmp_SS;
}

void auto_set_time()
{
    u8 tmp[14] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    u8 year=0,month=0,day=0,hour=0,minute=0,second=0;
    int index=0;

    while(1)
    {
        printf("Tell_ME_TIME\n");

        index=USART_Scanf_alltimedata(tmp);//index 是得到的数字个数，tmp中存放的是各个数字
        if(index<14)
        {
            printf("get_data_wrong!\n");
            continue;
        }
				else
				{
//		for(year=0;year<14;year++)
//			printf("get_data = %d \n",tmp[year]-0x30);//已验证成功

        year=(tmp[2]-0x30)*10+(tmp[3]-0x30);
        month=(tmp[2]-0x30)*10+(tmp[3]-0x30);
        day=(tmp[2]-0x30)*10+(tmp[3]-0x30);
        hour=(tmp[2]-0x30)*10+(tmp[3]-0x30);
        minute=(tmp[2]-0x30)*10+(tmp[3]-0x30);
        second=(tmp[2]-0x30)*10+(tmp[3]-0x30);
				}
    }

}


/*
 * 函数名：Time_Adjust
 * 描述  ：时间调节
 * 输入  ：用于读取RTC时间的结构体指针
 * 输出  ：无
 * 调用  ：外部调用
 */
void Time_Adjust(volatile struct rtc_time *tm)
{
    /* Wait until last write operation on RTC registers has finished */
    RTC_WaitForLastTask();

    /* Get time entred by the user on the hyperterminal */
    Time_Regulate(tm);

    /* Get wday */
    GregorianDay(tm);

    /* 修改当前RTC计数寄存器内容 */
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);	//使能PWR和BKP外设时钟
    PWR_BackupAccessCmd(ENABLE);	//使能RTC和后备寄存器访问
    RTC_SetCounter(mktimev(tm));	//设置RTC计数器的值

    RTC_WaitForLastTask();	//等待最近一次对RTC寄存器的写操作完成
    /* Wait until last write operation on RTC registers has finished */
}


/***         把RTC计数值转换成标准北京时间      ******/
static void Time_set_beijingTime(uint32_t TimeVar,volatile struct rtc_time *tm)
{
    static u16 daycnt=0;
    u32 timecount=0;
    u32 temp=0;
    u16 temp1=0;
    timecount=TimeVar;
    temp=timecount/86400;   //得到天数(秒钟数对应的)
    if(daycnt!=temp)//超过一天了
    {
        daycnt=temp;
        temp1=1970;	//从1970年开始
        while(temp>=365)
        {
            if(Is_Leap_Year(temp1))//是闰年
            {
                if(temp>=366)temp-=366;//闰年的秒钟数
                else
                {
                    temp1++;
                    break;
                }
            }
            else temp-=365;	  //平年
            temp1++;
        }
        tm->tm_year =temp1;//得到年份
        temp1=0;
        while(temp>=28)//超过了一个月
        {
            if(Is_Leap_Year(tm->tm_year)&&temp1==1)//当年是不是闰年/2月份
            {
                if(temp>=29)temp-=29;//闰年的秒钟数
                else break;
            }
            else
            {
                if(temp>=month_days[temp1])temp -= month_days[temp1];//平年
                else break;
            }
            temp1++;
        }
        tm->tm_mon =temp1+1;	//得到月份
        tm->tm_mday =temp+1;  	//得到日期
    }
    temp=timecount%86400;     		//得到秒钟数
    tm->tm_hour =temp/3600;     	//小时
    tm->tm_min=(temp%3600)/60; 	//分钟
    tm->tm_sec=(temp%3600)%60; 	//秒钟
}



/**						根据时间创建文件	，前提条件是系统运行了。		****/
static void create_file(volatile struct rtc_time *time,volatile create_flag *flag,module_state*state)
{
    static int i =0;
    unsigned int temp = 0;
    if(state->run ) {

        if( (12 == time->tm_hour) && (0 == time->tm_min) && (0 ==time->tm_sec) ) { //在每天中午12时进行天文件打开
            flag->Open_ActDerec_flag = ~0;  																				//打开一天的目录文件夹
        }
        if( (0 == time->tm_min) && (0 ==time->tm_sec) ) { 													//在每个小时00:00时进EXCEL文件打开
            if( 12 == time->tm_hour ) {
                if(flag->Open_ActDerec_flag) {
                    flag->Open_ActiveExcel_flag = ~0;  															//打开一天的目录文件夹
                }
            } else flag->Open_ActiveExcel_flag = ~0;  															//打开一天的目录文件夹
        }
        if(struct_active_file.res_state) {   																				//如果文件是打开状态
            flag->Write_Data_flag = ~0;   																					//写数据到表中
        }
    }
}

/***创建文件系统文件夹	1s运行一次***/
void creat_file_control(void) {
    if (TimeDisplay == 1) {
        // printf("module.run = %d\r\n",module.run);
        if( module.run) {              //如果机器开始运行
            Time_set_beijingTime(RTC_GetCounter(),&systmtime); //当前系统时间
            Time_set_beijingTime(RTC_GetCounter()-86400,&BeformSystmtime);//当前系统前一天的数据。
            Time_set_beijingTime(RTC_GetCounter()+86400,&AfterSystmtime);//当前系统前一天的数据。
            create_file(&systmtime,&create_file_flag,&module);  //创建/写数据文件管理

        }
        TimeDisplay = 0;
    }
}



void refresh_system_time()
{
    Time_set_beijingTime(RTC_GetCounter(),&systmtime); //当前系统时间
    Time_set_beijingTime(RTC_GetCounter()-86400,&BeformSystmtime);//当前系统前一天的数据。
    Time_set_beijingTime(RTC_GetCounter()+86400,&AfterSystmtime);//当前系统前一天的数据。
}
/************************END OF FILE***************************************/
